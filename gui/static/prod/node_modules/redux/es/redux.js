import $$observable from"../../symbol-observable/es/index.js";var ActionTypes={INIT:"@@redux/INIT"+Math.random().toString(36).substring(7).split("").join("."),REPLACE:"@@redux/REPLACE"+Math.random().toString(36).substring(7).split("").join(".")},_typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_extends=Object.assign||function(target){for(var i=1,source;i<arguments.length;i++){source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key]}}}return target};function isPlainObject(obj){if("object"!==("undefined"===typeof obj?"undefined":_typeof(obj))||null===obj)return!1;var proto=obj;while(null!==Object.getPrototypeOf(proto)){proto=Object.getPrototypeOf(proto)}return Object.getPrototypeOf(obj)===proto}function createStore(reducer,preloadedState,enhancer){var _ref2;if("function"===typeof preloadedState&&"undefined"===typeof enhancer){enhancer=preloadedState;preloadedState=void 0}if("undefined"!==typeof enhancer){if("function"!==typeof enhancer){throw new Error("Expected the enhancer to be a function.")}return enhancer(createStore)(reducer,preloadedState)}if("function"!==typeof reducer){throw new Error("Expected the reducer to be a function.")}var currentReducer=reducer,currentState=preloadedState,currentListeners=[],nextListeners=currentListeners,isDispatching=!1;function ensureCanMutateNextListeners(){if(nextListeners===currentListeners){nextListeners=currentListeners.slice()}}function getState(){if(isDispatching){throw new Error("You may not call store.getState() while the reducer is executing. "+"The reducer has already received the state as an argument. "+"Pass it down from the top reducer instead of reading it from the store.")}return currentState}function subscribe(listener){if("function"!==typeof listener){throw new Error("Expected the listener to be a function.")}if(isDispatching){throw new Error("You may not call store.subscribe() while the reducer is executing. "+"If you would like to be notified after the store has been updated, subscribe from a "+"component and invoke store.getState() in the callback to access the latest state. "+"See https://redux.js.org/api-reference/store#subscribe(listener) for more details.")}var isSubscribed=!0;ensureCanMutateNextListeners();nextListeners.push(listener);return function(){if(!isSubscribed){return}if(isDispatching){throw new Error("You may not unsubscribe from a store listener while the reducer is executing. "+"See https://redux.js.org/api-reference/store#subscribe(listener) for more details.")}isSubscribed=!1;ensureCanMutateNextListeners();var index=nextListeners.indexOf(listener);nextListeners.splice(index,1)}}function dispatch(action){if(!isPlainObject(action)){throw new Error("Actions must be plain objects. "+"Use custom middleware for async actions.")}if("undefined"===typeof action.type){throw new Error("Actions may not have an undefined \"type\" property. "+"Have you misspelled a constant?")}if(isDispatching){throw new Error("Reducers may not dispatch actions.")}try{isDispatching=!0;currentState=currentReducer(currentState,action)}finally{isDispatching=!1}for(var listeners=currentListeners=nextListeners,i=0,listener;i<listeners.length;i++){listener=listeners[i];listener()}return action}dispatch({type:ActionTypes.INIT});return _ref2={dispatch:dispatch,subscribe:subscribe,getState:getState,replaceReducer:function(nextReducer){if("function"!==typeof nextReducer){throw new Error("Expected the nextReducer to be a function.")}currentReducer=nextReducer;dispatch({type:ActionTypes.REPLACE})}},_ref2[$$observable]=function(){var _ref,outerSubscribe=subscribe;return _ref={subscribe:function(observer){if("object"!==("undefined"===typeof observer?"undefined":_typeof(observer))||null===observer){throw new TypeError("Expected the observer to be an object.")}function observeState(){if(observer.next){observer.next(getState())}}observeState();var unsubscribe=outerSubscribe(observeState);return{unsubscribe:unsubscribe}}},_ref[$$observable]=function(){return this},_ref},_ref2}function warning(message){if("undefined"!==typeof console&&"function"===typeof console.error){console.error(message)}try{throw new Error(message)}catch(e){}}function getUndefinedStateErrorMessage(key,action){var actionType=action&&action.type;return"Given "+(actionType&&"action \""+(actionType+"")+"\""||"an action")+", reducer \""+key+"\" returned undefined. "+"To ignore an action, you must explicitly return the previous state. "+"If you want this reducer to hold no value, you can return null instead of undefined."}function getUnexpectedStateShapeWarningMessage(inputState,reducers,action,unexpectedKeyCache){var reducerKeys=Object.keys(reducers),argumentName=action&&action.type===ActionTypes.INIT?"preloadedState argument passed to createStore":"previous state received by the reducer";if(0===reducerKeys.length){return"Store does not have a valid reducer. Make sure the argument passed "+"to combineReducers is an object whose values are reducers."}if(!isPlainObject(inputState)){return"The "+argumentName+" has unexpected type of \""+{}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1]+"\". Expected argument to be an object with the following "+("keys: \""+reducerKeys.join("\", \"")+"\"")}var unexpectedKeys=Object.keys(inputState).filter(function(key){return!reducers.hasOwnProperty(key)&&!unexpectedKeyCache[key]});unexpectedKeys.forEach(function(key){unexpectedKeyCache[key]=!0});if(action&&action.type===ActionTypes.REPLACE)return;if(0<unexpectedKeys.length){return"Unexpected "+(1<unexpectedKeys.length?"keys":"key")+" "+("\""+unexpectedKeys.join("\", \"")+"\" found in "+argumentName+". ")+"Expected to find one of the known reducer keys instead: "+("\""+reducerKeys.join("\", \"")+"\". Unexpected keys will be ignored.")}}function assertReducerShape(reducers){Object.keys(reducers).forEach(function(key){var reducer=reducers[key],initialState=reducer(void 0,{type:ActionTypes.INIT});if("undefined"===typeof initialState){throw new Error("Reducer \""+key+"\" returned undefined during initialization. "+"If the state passed to the reducer is undefined, you must "+"explicitly return the initial state. The initial state may "+"not be undefined. If you don't want to set a value for this reducer, "+"you can use null instead of undefined.")}var type="@@redux/PROBE_UNKNOWN_ACTION_"+Math.random().toString(36).substring(7).split("").join(".");if("undefined"===typeof reducer(void 0,{type:type})){throw new Error("Reducer \""+key+"\" returned undefined when probed with a random type. "+("Don't try to handle "+ActionTypes.INIT+" or other actions in \"redux/*\" ")+"namespace. They are considered private. Instead, you must return the "+"current state for any unknown actions, unless it is undefined, "+"in which case you must return the initial state, regardless of the "+"action type. The initial state may not be undefined, but can be null.")}})}function combineReducers(reducers){for(var reducerKeys=Object.keys(reducers),finalReducers={},i=0,key;i<reducerKeys.length;i++){key=reducerKeys[i];if("production"!==process.env.NODE_ENV){if("undefined"===typeof reducers[key]){warning("No reducer provided for key \""+key+"\"")}}if("function"===typeof reducers[key]){finalReducers[key]=reducers[key]}}var finalReducerKeys=Object.keys(finalReducers),unexpectedKeyCache=void 0;if("production"!==process.env.NODE_ENV){unexpectedKeyCache={}}var shapeAssertionError;try{assertReducerShape(finalReducers)}catch(e){shapeAssertionError=e}return function(){var state=0<arguments.length&&arguments[0]!==void 0?arguments[0]:{},action=arguments[1];if(shapeAssertionError){throw shapeAssertionError}if("production"!==process.env.NODE_ENV){var warningMessage=getUnexpectedStateShapeWarningMessage(state,finalReducers,action,unexpectedKeyCache);if(warningMessage){warning(warningMessage)}}for(var hasChanged=!1,nextState={},_i=0;_i<finalReducerKeys.length;_i++){var _key=finalReducerKeys[_i],reducer=finalReducers[_key],previousStateForKey=state[_key],nextStateForKey=reducer(previousStateForKey,action);if("undefined"===typeof nextStateForKey){var errorMessage=getUndefinedStateErrorMessage(_key,action);throw new Error(errorMessage)}nextState[_key]=nextStateForKey;hasChanged=hasChanged||nextStateForKey!==previousStateForKey}return hasChanged?nextState:state}}function bindActionCreator(actionCreator,dispatch){return function(){return dispatch(actionCreator.apply(this,arguments))}}function bindActionCreators(actionCreators,dispatch){if("function"===typeof actionCreators){return bindActionCreator(actionCreators,dispatch)}if("object"!==("undefined"===typeof actionCreators?"undefined":_typeof(actionCreators))||null===actionCreators){throw new Error("bindActionCreators expected an object or a function, instead received "+(null===actionCreators?"null":"undefined"===typeof actionCreators?"undefined":_typeof(actionCreators))+". "+"Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?")}for(var keys=Object.keys(actionCreators),boundActionCreators={},i=0;i<keys.length;i++){var key=keys[i],actionCreator=actionCreators[key];if("function"===typeof actionCreator){boundActionCreators[key]=bindActionCreator(actionCreator,dispatch)}}return boundActionCreators}function compose(){for(var _len=arguments.length,funcs=Array(_len),_key=0;_key<_len;_key++){funcs[_key]=arguments[_key]}if(0===funcs.length){return function(arg){return arg}}if(1===funcs.length){return funcs[0]}return funcs.reduce(function(a,b){return function(){return a(b.apply(void 0,arguments))}})}function applyMiddleware(){for(var _len=arguments.length,middlewares=Array(_len),_key=0;_key<_len;_key++){middlewares[_key]=arguments[_key]}return function(createStore){return function(){for(var _len2=arguments.length,args=Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2]}var store=createStore.apply(void 0,args),_dispatch=function(){throw new Error("Dispatching while constructing your middleware is not allowed. "+"Other middleware would not be applied to this dispatch.")},middlewareAPI={getState:store.getState,dispatch:function(){return _dispatch.apply(void 0,arguments)}},chain=middlewares.map(function(middleware){return middleware(middlewareAPI)});_dispatch=compose.apply(void 0,chain)(store.dispatch);return _extends({},store,{dispatch:_dispatch})}}}function isCrushed(){}if("production"!==process.env.NODE_ENV&&"string"===typeof isCrushed.name&&"isCrushed"!==isCrushed.name){warning("You are currently using minified code outside of NODE_ENV === 'production'. "+"This means that you are running a slower development build of Redux. "+"You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify "+"or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) "+"to ensure you have the correct code for your production build.")}export{createStore,combineReducers,bindActionCreators,applyMiddleware,compose,ActionTypes as __DO_NOT_USE__ActionTypes};