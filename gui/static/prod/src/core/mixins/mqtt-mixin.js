import{Paho}from"../libs/paho-mqtt.js";function _onConnect(){console.log("onConnect");for(var ps=window.MQTTclient.p_registers,i=ps.length-1;0<=i;i--){const p=ps[i];var element=p.element,channel=p.channel;window.MQTTclient.client.subscribe(channel);if(!window.MQTTclient.registers[channel]){window.MQTTclient.registers[channel]=[]}console.info("Subscribed to "+channel+" for "+element);window.MQTTclient.registers[channel].push(element)}}function _onConnectFail(){console.log("onConnectFailure")}class Mqtt{setUp(){const self=this;if(window.MQTTclient){return}const host=window.location.hostname,clientId="myclientid_"+parseInt(1e4*Math.random(),10),client=new Paho.MQTT.Client(host,443,"/ws",clientId);self.options={timeout:3,useSSL:!0,cleanSession:!0,userName:"guest",password:"guest",onSuccess:_onConnect,onFailure:_onConnectFail};window.MQTTclient={};window.MQTTclient.client=client;window.MQTTclient.registers={};window.MQTTclient.p_registers=[];client.onConnectionLost=self._onConnectionLost;client.onMessageArrived=self._onMessageArrived;this._connect();return this.client}_connect(){}disconnect(){window.MQTTclient.client.disconnect()}_onConnectionLost(responseObject){console.log(responseObject);console.log("onConnectionLost:"+responseObject.errorMessage);const client=window.MQTTclient.client;client.connect({timeout:3,useSSL:!0,cleanSession:!0,userName:"guest",password:"guest",onSuccess:_onConnect,onFailure:_onConnectFail})}_onMessageArrived(message){console.log("onMessageArrived");console.log(message);var elements=window.MQTTclient.registers[message.destinationName];if(elements){elements.forEach(function(el){el.onMqttMessage(message)})}else{console.error("message from un-subscribed channel: "+message.destinationName)}}publish(message,destination){var msg=new Paho.MQTT.Message(message);msg.destinationName=destination;this.client.send(msg)}subscribe(channel){this.client.subscribe(channel);alert("Subscribed")}_register(element,channel){window.MQTTclient.client.subscribe(channel);if(!window.MQTTclient.registers[channel]){window.MQTTclient.registers[channel]=[]}console.info("Subscribed to "+channel+" for "+element);window.MQTTclient.registers[channel].push(element)}register(element,channel){if(window.MQTTclient.client.isConnected()){this._register(element,channel)}else{window.MQTTclient.p_registers.push({channel:channel,element:element})}}registerG(element){if(!window.MQTTclient.registers[window.MQTTclient.unique_session_channel]){window.MQTTclient.registers[window.MQTTclient.unique_session_channel]=[]}window.MQTTclient.registers[window.MQTTclient.unique_session_channel].push(element)}connect(){console.log(JSON.stringify(this.options));this.client.connect(this.options)}}export const mqttMixin=BaseClass=>class extends BaseClass{constructor(){super();const mqtt=new Mqtt,c=mqtt.setUp();this.mqtt=mqtt}static get properties(){return{mqtt:Object}}register(element,channel){if(window.MQTTclient.client.isConnected()){this.mqtt._register(element,channel)}else{window.MQTTclient.p_registers.push({channel:channel,element:element})}}onMqttMessage(){}};