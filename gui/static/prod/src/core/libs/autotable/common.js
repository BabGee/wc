import{defaultStyles}from"./config.js";import state from"./state.js";import{assign}from"./polyfills.js";export function getStringWidth(text,styles){applyStyles(styles);const textArr=Array.isArray(text)?text:[text],widestLineWidth=textArr.map(text=>state().doc.getTextWidth(text)).map(val=>Math.floor(1e4*val)/1e4).reduce((a,b)=>Math.max(a,b),0),fontSize=styles.fontSize/state().scaleFactor();return widestLineWidth}export function ellipsize(text,width,styles,ellipsizeStr="..."){if(Array.isArray(text)){const value=[];text.forEach(function(str,i){value[i]=ellipsize(str,width,styles,ellipsizeStr)});return value}const precision=1e4*state().scaleFactor();width=Math.ceil(width*precision)/precision;if(width>=getStringWidth(text,styles)){return text}while(width<getStringWidth(text+ellipsizeStr,styles)){if(1>=text.length){break}text=text.substring(0,text.length-1)}return text.trim()+ellipsizeStr}export function addTableBorder(){const table=state().table,styles={lineWidth:table.settings.tableLineWidth,lineColor:table.settings.tableLineColor};applyStyles(styles);const fs=getFillStyle(styles);if(fs){state().doc.rect(table.pageStartX,table.pageStartY,table.width,table.cursor.y-table.pageStartY,fs)}}export function getFillStyle(styles){const drawLine=0<styles.lineWidth,drawBackground=styles.fillColor||0===styles.fillColor;if(drawLine&&drawBackground){return"DF"}else if(drawLine){return"S"}else if(drawBackground){return"F"}else{return!1}}export function applyUserStyles(){applyStyles(state().table.userStyles)}export function applyStyles(styles){const doc=state().doc,styleModifiers={fillColor:doc.setFillColor,textColor:doc.setTextColor,fontStyle:doc.setFontStyle,lineColor:doc.setDrawColor,lineWidth:doc.setLineWidth,font:doc.setFont,fontSize:doc.setFontSize};Object.keys(styleModifiers).forEach(function(name){const style=styles[name],modifier=styleModifiers[name];if("undefined"!==typeof style){if(Array.isArray(style)){modifier.apply(this,style)}else{modifier(style)}}})}export function marginOrPadding(value,defaultValue){let newValue={};if(Array.isArray(value)){if(4<=value.length){newValue={top:value[0],right:value[1],bottom:value[2],left:value[3]}}else if(3===value.length){newValue={top:value[0],right:value[1],bottom:value[2],left:value[1]}}else if(2===value.length){newValue={top:value[0],right:value[1],bottom:value[0],left:value[1]}}else if(1===value.length){value=value[0]}else{value=defaultValue}}else if("object"===typeof value){if(value.vertical){value.top=value.vertical;value.bottom=value.vertical}if(value.horizontal){value.right=value.horizontal;value.left=value.horizontal}for(const side of["top","right","bottom","left"]){newValue[side]=value[side]||0===value[side]?value[side]:defaultValue}}if("number"===typeof value){newValue={top:value,right:value,bottom:value,left:value}}return newValue}export function styles(styles){styles=Array.isArray(styles)?styles:[styles];return assign(defaultStyles(),...styles)}